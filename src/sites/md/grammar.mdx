import Section from "@components/Section.jsx"
import {Math, DMath} from "@components/Katex.jsx"
import Mermaid from "@components/Mermaid.jsx"

## Grammatik

Wir haben das bereits im letzten Kapitel angeschaut, eine **Grammatik** für eine **Computersprache** gibt uns die Regeln an, wie wir diese Sprache interpretieren müssen. Die Grammatik ist also die Grundlage für die Syntax von einer **Computersprache**.

Eine Grammatik besteht immer aus mehreren Komponenten. Ein Komponente ist das **Alphabet** der Sprache. Das **Alphabet** gibt an, welche Zeichen in der **Sprache** verwendet werden können. Wir haben bereits 3 **Alphabete** kennengelernt, jeweils für das **Binär-**, **Dezimal-** und **Hexadezimalsystem**. Ein **Alphabet** können wir jeweils so angeben:

<DMath>{String.raw`\begin{align*}
\Sigma_\mathrm{Bin} &= \{0, 1\}\\
\Sigma_\mathrm{Dec} &= \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\} \\
\Sigma_\mathrm{Hex} &= \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\}
\end{align*}`}</DMath>

Wir können nun beliebig viele von diesen **Terminalsymbolen** aneinander hängen, und wir bekommen stehts ein Wort, das für diese Sprache gültig ist. Wenn wir hier von Wörtern sprechen, dann meinen wir damit einfach eine Zeichenfolge, die für diese Sprache gültig ist.

<Section classes="full-width content-grid">

    ## Sprache einschränken

    Meistens möchten wir nicht mit der ganzen Sprache arbeiten, sondern nur mit einer Untermenge. Das haben wir bereits gesehen, als wir mit Binärzahlen und auch im Hexadezimalsystem gearbeitet haben. Im Hexadezimalsystem, haben wir gesagt, dass und nur 2-stellige Zahlen interessieren. Wenn wir eine solche Einschränkung auf die Sprache machen, dann müssen wir dafür eine Grammatik definieren. Die Grammatik wird in mehreren Regeln definiert. Diese Regeln können wir mit **Syntaxdiagrammen** beschreiben. Dazu machen wir gleich ein Beispiel für 2-stellige Hexadezimalzahlen:

    **Hexzahl:**
    <Mermaid>
    {String.raw`
    ---
    config:
      theme: 'dark'
    ---
    graph LR
      A[Start] --> D(0) --> B[Ziffer] --> C[End]
      A --> E[Ziffer] --> F[Ziffer] --> C
    `}
    </Mermaid>

    **Ziffer:**
    <Mermaid>
    {String.raw`
    ---
    config:
      theme: 'dark'
    ---
    graph LR
      A[Start] --> 0(0) --> C[End]
      A --> 1(1) --> C
      A --> 2(2) --> C
      A --> 3(3) --> C
      A --> 4(4) --> C
      A --> 5(5) --> C
      A --> 6(6) --> C
      A --> 7(7) --> C
      A --> 8(8) --> C
      A --> 9(9) --> C
      A --> Z(A) --> C
      A --> B(B) --> C
      A --> G(C) --> C
      A --> D(D) --> C
      A --> E(E) --> C
      A --> F(F) --> C
    `}
    </Mermaid>

    Von einer Grammatik muss so lange eine Regel angewendet werden, bis nur noch **Terminalsymbole** im Wort vorkommen. Wenn wir also mit der Regel `Hexzahl` starten, dann bauen wir uns zum Beispiel das Wort `0{Ziffer}`. Dann müssen wir noch dir Regel für `Ziffer` anwenden, und landen dann zum Beispiel bei `0D`. Das ist eine gültige 2-stellige Hexadezimalzahl. Wir können jeweils die Grammatik dafür verwenden, um herauszufinden, ob ein Wort gültig ist.

</Section>
